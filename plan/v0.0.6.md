# VSCode Semantic Search Extension - v0.0.6

## Focus: Engineering Quality & Automation

Strengthen engineering practices around observability, testing, and CI to make the extension more reliable and easier to maintain.

## Goals

- **Log integration**: Introduce a consistent logging layer for extension + webviews.
- **VS Code test integration**: Use the official VS Code test runner and improve coverage.
- **GitHub Actions integration**: Add CI workflows for lint, test, and (later) release.

---

## 1. Logging Integration

### Objectives

- Provide structured, leveled logging (info/warn/error/debug) across services and commands.
- Make logs easy to enable/inspect via VS Code Output channel and configuration.
- Avoid noisy logs in normal usage while still being helpful for debugging.

### Design

1. **Central logging utility**
   - Create a `Logger` abstraction (e.g. `src/services/logger.ts`).
   - Backed by a single VS Code `OutputChannel` (e.g. `Semantic Search`).
   - Support log levels: `error`, `warn`, `info`, `debug`.
   - Include simple context metadata (e.g. component name) in messages.

2. **Configuration surface**
   - Add settings under `semantic-search.logging` in `package.json`:
     - `level`: `error | warn | info | debug` (default `warn`).
     - `enableFileLog` (optional, future): reserved for potential file-based logging.
   - Respect configuration at runtime and allow dynamic change (listen to `onDidChangeConfiguration`).

3. **Integration points**
   - Replace ad-hoc `console.log` usages with `Logger` calls in:
     - `extension.ts` (activation, deactivation, command registration).
     - `services/*` (indexing, search, embeddings, file watcher, vector DB).
     - Long-running operations (indexing, search) emit lifecycle events: start, progress (optional), success/failure.
   - Ensure sensitive content (API keys, raw prompts) is never logged.

4. **Webview / UI logging** (lightweight)
   - For webviews that need diagnostics, define a narrow message channel to send log events to the extension host, which then logs via `Logger`.
   - Guard behind `debug` level to avoid noise.

### Testing

- Unit tests for `Logger` behavior:
  - Respects configured log level.
  - Formats messages with context consistently.
- Smoke tests (manual initially):
  - Toggle log level and verify expected volume of messages.
  - Confirm no secrets or large payloads are written.

---

## 2. VS Code Test Integration

### Objectives

- Align with VS Code's recommended integration testing setup.
- Run both unit and integration tests via `npm test` and the VS Code Test Runner.
- Make it easy to run tests in CI and locally.

### Design

1. **Test harness structure**
   - Use the VS Code testing pattern from docs: create a `src/test/suite` (or reuse existing `test/`) with:
     - `runTest.ts` entry point for the VS Code test runner.
     - One or more `extension.test.ts` / feature test files using Mocha (or existing test framework).
   - Ensure `vscode` is loaded via the `@vscode/test-electron` (or current recommended) package.

2. **NPM scripts & config**
   - Add/update scripts in `package.json`:
     - `test`: run unit + extension tests via `@vscode/test-*` runner.
     - `test:unit`: fast unit tests not requiring VS Code instance.
     - `test:extension`: integration tests that launch VS Code.
   - Ensure `ts-node`/`tsc` config (via `tsconfig.json`) supports compiling test sources if needed.

3. **Test coverage improvements**
   - Add/extend tests for:
     - Command registration and basic command behavior (e.g. building index, running search).
     - `SearchService`, `IndexingService`, `TokenChunker` core logic.
   - Optionally integrate coverage tooling (e.g. `nyc` / `c8`) later; for v0.0.6 keep it minimal but structured.

### Testing

- Verify `npm test` passes locally and runs the VS Code test runner.
- Confirm tests can target a sample workspace (fixture) without depending on the userâ€™s actual workspace.

---

## 3. GitHub Actions Integration

### Objectives

- Automatically lint and test on each push/PR.
- Keep the workflow simple and fast to encourage frequent contributions.
- Lay groundwork for future release automation (vsix build/publish).

### Design

1. **CI workflow**
   - Add `.github/workflows/ci.yml` with jobs:
     - Trigger on `push` and `pull_request` to `main` and feature branches.
     - `build-and-test` job:
       - Use `actions/checkout`.
       - Use `actions/setup-node` with appropriate Node version (from `engines` or `.nvmrc` if present).
       - `npm ci` (or `npm install` fallback).
       - `npm run lint` (if available) and `npm test`.

2. **Matrix & caching (optional, later)**
   - Begin with a single Node version.
   - Optionally add matrix for LTS versions in future iteration.
   - Enable `actions/cache` for `~/.npm` to speed up runs (optional for v0.0.6).

3. **Status & badges**
   - After CI is green on `main`, add a build status badge to `README.md`.

### Testing

- Validate workflow by pushing a branch and confirming CI status in GitHub.
- Intentionally break a test locally to ensure CI fails as expected.

---

## Out of Scope (Future)

- Automated packaging and publishing of the extension to the Marketplace.
- Advanced observability (structured JSON logs, external log sinks).
- Code coverage reporting to external services (Codecov, Coveralls, etc.).
