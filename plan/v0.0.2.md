# VSCode Semantic Search Extension - v0.0.2

## Overview

Build upon v0.0.1 foundation to add **ChromaDB server integration**, incremental indexing, configuration options, and improved user experience.

## Goals

- **Integrate ChromaDB executable for persistent vector storage**
- Improve indexing performance with incremental updates
- Add user configuration options
- Enhance search experience with filtering
- Add persistence for ChromaDB data

## RFC Reference

See [doc/rfc/chroma.md](../doc/rfc/chroma.md) for detailed technical design of ChromaDB integration.

## Features

### 1. ChromaDB Server Integration (NEW - Critical)

> **Note**: The `chromadb` npm package is a client library that requires a running Chroma server. It does not support embedded mode like the Python client. We must bundle and manage a Chroma executable.

#### 1.1 Chroma Process Manager
- [x] Create `ChromaProcessManager` service class
- [x] Implement server lifecycle management (start/stop)
- [x] Add health check mechanism with retry logic
- [x] Implement automatic port allocation
- [x] Handle graceful shutdown on extension deactivate

#### 1.2 Platform-Specific Binaries
- [ ] Download/build Chroma executables for each platform:
  - [ ] Windows x64 (`chroma-win-x64.exe`)
  - [ ] Linux x64 (`chroma-linux-x64`)
  - [ ] macOS Intel (`chroma-darwin-x64`)
  - [ ] macOS Apple Silicon (`chroma-darwin-arm64`)
- [x] Add binaries to extension package under `bin/` directory (structure created)
- [x] Implement platform detection logic
- [x] Handle executable permissions on Unix systems

#### 1.3 Persistent Storage
- [x] Store ChromaDB data in VS Code globalStorage
- [x] Implement data persistence across extension restarts
- [ ] Add migration support for schema changes

#### 1.4 Error Handling & Recovery
- [x] Implement crash detection and auto-restart
- [x] Add exponential backoff for connection retries
- [x] Show user-friendly error notifications
- [x] Log detailed diagnostics for debugging

### 2. Incremental Indexing
- [x] Watch for file changes using `vscode.workspace.onDidSaveTextDocument`
- [x] Auto-reindex modified files on save (configurable)
- [x] Batch reindex for multiple changes (debouncing implemented)
- [x] Smart detection of renamed/moved files

### 3. Configuration Settings
- [x] `semanticSearch.autoIndex`: Enable/disable auto-indexing on file save
- [x] `semanticSearch.chunkSize`: Number of lines per chunk (default: 50)
- [x] `semanticSearch.chunkOverlap`: Overlap between chunks (default: 10)
- [x] `semanticSearch.maxResults`: Default number of search results (default: 10)
- [x] `semanticSearch.excludePatterns`: Additional patterns to exclude
- [x] `semanticSearch.includePatterns`: Additional patterns to include
- [x] `semanticSearch.chroma.port`: Port for Chroma server (0 = auto-assign)
- [x] `semanticSearch.chroma.logLevel`: Chroma server log level
- [x] `semanticSearch.chroma.startupTimeout`: Timeout for server startup

### 4. Enhanced Search UI
- [x] Search results webview with syntax highlighting
- [x] Filter by file type
- [x] Filter by folder/path
- [x] Sort by relevance or file path
- [x] Preview snippets with context

### 5. Status Bar Integration
- [x] Show indexing status in status bar
- [x] Show Chroma server status (running/stopped/error)
- [x] Click to show detailed progress (shows server logs)
- [x] Indicator for stale index

### 6. Improved Index Sidebar
- [x] Group files by folder
- [x] Show file type icons
- [x] Context menu for reindex single file
- [x] Show chunk count per file
- [x] Collapsible workspace sections

### 7. Performance Optimizations
- [ ] Parallel file reading during indexing
- [ ] Batch ChromaDB insertions
- [ ] Cache embedding results
- [ ] Limit concurrent operations

## Technical Tasks

### Chroma Process Manager Implementation
```typescript
// src/services/chromaProcessManager.ts
import * as vscode from 'vscode';
import { ChildProcess, spawn } from 'child_process';
import * as path from 'path';
import * as net from 'net';

export interface ChromaServerConfig {
    port: number;
    host: string;
    persistPath: string;
    logLevel: 'debug' | 'info' | 'warning' | 'error';
}

export class ChromaProcessManager {
    private process: ChildProcess | null = null;
    private port: number = 0;
    private readonly defaultPort = 8765;
    
    constructor(private context: vscode.ExtensionContext) {}
    
    async start(): Promise<void> {
        // Find available port
        this.port = await this.findAvailablePort();
        
        // Get executable path for current platform
        const execPath = this.getChromaExecutablePath();
        
        // Get persist directory
        const persistPath = path.join(
            this.context.globalStorageUri.fsPath, 
            'chroma'
        );
        
        // Spawn Chroma server
        this.process = spawn(execPath, [
            'run',
            '--host', '127.0.0.1',
            '--port', this.port.toString(),
            '--path', persistPath
        ]);
        
        // Wait for server to be ready
        await this.waitForReady();
    }
    
    async stop(): Promise<void> {
        if (this.process) {
            this.process.kill('SIGTERM');
            // Wait for graceful shutdown with timeout
            await this.waitForExit(5000);
        }
    }
    
    getServerUrl(): string {
        return `http://127.0.0.1:${this.port}`;
    }
    
    private async findAvailablePort(): Promise<number> {
        // Try default port first, then find random available
        const port = await this.isPortAvailable(this.defaultPort) 
            ? this.defaultPort 
            : await this.getRandomAvailablePort();
        return port;
    }
    
    private getChromaExecutablePath(): string {
        const platform = process.platform;
        const arch = process.arch;
        const ext = platform === 'win32' ? '.exe' : '';
        
        let platformDir: string;
        if (platform === 'win32') {
            platformDir = 'win32-x64';
        } else if (platform === 'darwin') {
            platformDir = arch === 'arm64' ? 'darwin-arm64' : 'darwin-x64';
        } else {
            platformDir = 'linux-x64';
        }
        
        return path.join(
            this.context.extensionPath,
            'bin',
            platformDir,
            `chroma${ext}`
        );
    }
}
```

### Updated ChromaService
```typescript
// src/services/chromaService.ts
export class ChromaService {
    private client: ChromaClient | null = null;
    private processManager: ChromaProcessManager;
    
    constructor(private context: vscode.ExtensionContext) {
        this.processManager = new ChromaProcessManager(context);
    }
    
    async initialize(): Promise<void> {
        // Start the Chroma server process
        await this.processManager.start();
        
        // Connect client to the server
        const { ChromaClient } = require('chromadb');
        this.client = new ChromaClient({
            path: this.processManager.getServerUrl()
        });
        
        // Get or create collection with embedding function
        const { DefaultEmbeddingFunction } = require('chromadb-default-embed');
        this.embeddingFunction = new DefaultEmbeddingFunction();
        
        this.collection = await this.client.getOrCreateCollection({
            name: this.collectionName,
            embeddingFunction: this.embeddingFunction,
        });
    }
    
    async dispose(): Promise<void> {
        await this.processManager.stop();
    }
}
```

### File Watcher Implementation
```typescript
// Watch for file changes
vscode.workspace.onDidSaveTextDocument(async (document) => {
    if (config.autoIndex && shouldIndexFile(document.uri.fsPath)) {
        await indexingService.indexFile(document.uri, workspacePath);
    }
});
```

### Configuration Schema
```json
{
    "semanticSearch.autoIndex": {
        "type": "boolean",
        "default": false,
        "description": "Automatically reindex files on save"
    },
    "semanticSearch.chunkSize": {
        "type": "number",
        "default": 50,
        "description": "Number of lines per chunk"
    },
    "semanticSearch.chroma.port": {
        "type": "number",
        "default": 0,
        "description": "Port for Chroma server (0 = auto-assign)"
    },
    "semanticSearch.chroma.logLevel": {
        "type": "string",
        "enum": ["debug", "info", "warning", "error"],
        "default": "warning",
        "description": "Chroma server log level"
    },
    "semanticSearch.chroma.startupTimeout": {
        "type": "number",
        "default": 30000,
        "description": "Timeout in ms for Chroma server to start"
    }
}
```

## Directory Structure (Updated)

```
extension/
├── bin/                          # Chroma executables (NEW)
│   ├── win32-x64/
│   │   └── chroma.exe
│   ├── linux-x64/
│   │   └── chroma
│   ├── darwin-x64/
│   │   └── chroma
│   └── darwin-arm64/
│       └── chroma
├── out/
├── src/
│   ├── services/
│   │   ├── chromaService.ts      # Updated to use process manager
│   │   ├── chromaProcessManager.ts  # NEW
│   │   ├── duckdbService.ts
│   │   ├── indexingService.ts
│   │   └── searchService.ts
│   └── ...
├── doc/
│   └── rfc/
│       └── chroma.md             # RFC document
└── package.json
```

## Data Storage Layout

```
globalStorage/semantic-search/
├── chroma/                       # ChromaDB persistent data
│   ├── chroma.sqlite3
│   └── [collection-uuid]/
├── duckdb/
│   └── metadata.db
└── config.json
```

## Migration Notes

- **Breaking Change**: v0.0.1 in-memory ChromaDB data will be lost on upgrade
- Existing DuckDB metadata should continue to work
- First start of v0.0.2 will require full re-indexing
- New configuration options should have sensible defaults

## Testing Checklist

- [ ] Chroma server starts correctly on all platforms
- [ ] Chroma server stops gracefully on extension deactivate
- [ ] Server auto-restarts on crash
- [ ] Port conflicts are handled correctly
- [ ] Index data persists across extension restarts
- [ ] Incremental indexing works correctly
- [ ] File watcher triggers on save
- [ ] Configuration changes apply immediately
- [ ] Search filters work as expected
- [ ] Status bar updates correctly
- [ ] Performance is acceptable for large workspaces (1000+ files)

## Dependencies

**Existing:**
- `chromadb` - Vector database client
- `chromadb-default-embed` - Embedding model
- `duckdb` - Metadata storage
- `minimatch` - Pattern matching

**New:**
- Bundled Chroma executables (~50-100MB per platform)

## Implementation Timeline

### Week 1: Chroma Process Manager
- Create `ChromaProcessManager` class
- Implement lifecycle management
- Port allocation and health checks

### Week 2: Binary Distribution & Integration
- Download/build Chroma binaries
- Update `ChromaService` integration
- Test on all platforms

### Week 3: Incremental Indexing & Config
- File watcher implementation
- Configuration settings
- Status bar integration

### Week 4: Testing & Polish
- Cross-platform testing
- Performance optimization
- Documentation
